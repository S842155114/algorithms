package com.fickle.code.sort;

/**
 * 我们知道，堆分为"最大堆"和"最小堆"。最大堆通常被用来进行"升序"排序，而最小堆通常被用来进行"降序"排序。
 * 鉴于最大堆和最小堆是对称关系，理解其中一种即可。
 * 本文将对最大堆实现的升序排序进行详细说明。
 * 最大堆进行升序排序的基本思想:
 * ① 初始化堆: 将数列a[1...n]构造成最大堆。
 * ② 交换数据: 取堆顶元素，将堆顶元素放入数组，将剩余数据重新构造堆。 将a[1]和a[n]交换，使a[n]是a[1...n]中的最大值；然后将a[1...n-1]重新调整为最大堆。
 * 接着，将a[1]和a[n-1]交换，使a[n-1]是a[1...n-1]中的最大值；然后将a[1...n-2]重新调整为最大值。
 * 依次类推，直到整个数列都是有序的。
 * <p>
 * 堆排序的时间复杂度是O(N*lgN)。
 * 假设被排序的数列中有N个数。遍历一趟的时间复杂度是O(N)，需要遍历多少次呢?
 * 堆排序是采用的二叉堆进行排序的，二叉堆就是一棵二叉树，它需要遍历的次数就是二叉树的深度，而根据完全二叉树的定义，它的深度至少是lg(N+1)。
 * 最多是多少呢?
 * 由于二叉堆是完全二叉树，因此，它的深度最多也不会超过lg(2N)。
 * 因此，遍历一趟的时间复杂度是O(N)，而遍历次数介于lg(N+1)和lg(2N)之间；因此得出它的时间复杂度是O(N*lgN)。
 * <p>
 * 堆排序是不稳定的算法，它不满足稳定算法的定义。它在交换数据的时候，是比较父结点和子节点之间的数据，
 * 所以，即便是存在两个数值相等的兄弟节点，它们的相对顺序在排序也可能发生变化。
 *
 * @author Administrator
 * @apiNote com.fickle.code.sort
 */
public class Heap {
    /*
     * (最大)堆的向下调整算法
     *
     * 注: 数组实现的堆中，第N个节点的左孩子的索引值是(2N+1)，右孩子的索引是(2N+2)。
     *     其中，N为数组下标索引值，如数组中第1个数对应的N为0。
     *
     * 参数说明:
     *     a -- 待排序的数组
     *     start -- 被下调节点的起始位置(一般为0，表示从第1个开始)
     *     end   -- 截至范围(一般为数组中最后一个元素的索引)
     */
    public static void maxHeapDown(int[] a, int start, int end) {
        int c = start, l = c * 2 + 1, temp = a[c]; // c是当前节点，l是左孩子
        for (; l <= end; c = l, l = l * 2 + 1) {
            if (l < end && a[l] < a[l + 1]) { // 找到兄弟节点中较大的那一个
                l++;
            }
            if (a[l] <= temp) { // 如果大则顺序没问题
                break;
            } else { // 如果小则需要交换并对交换后的树进行比较
                a[c] = a[l];
                a[l] = temp;
            }

        }
    }

    /*
     * 堆排序(从小到大)
     *
     * 参数说明:
     *     a -- 待排序的数组
     *     n -- 数组的长度
     */
    public static void heapSortAsc(int[] a, int n) {
        int i, tmp;

        // 取最后一个节点的父节点 n/2-1，与孩子节点进行比较
        for (i = n / 2 - 1; i > 0; i--) {
            maxHeapDown(a, i, n - 1);
        }
        /**
         *                 83
         *             75     66
         *           47 22   18 53
         *          32
         */
        // 从最后一个元素开始对序列进行调整，不断的缩小调整的范围直到第一个元素
        for (i = n - 1; i > 0; i--) {
            // 取出上面最大堆中的堆顶元素，放入到数组的第i位
            // 交换a[0]和a[i]。交换后，a[i]是a[0...i]中最大的。
            tmp = a[0];
            a[0] = a[i];
            a[i] = tmp;
            // 因为已经将堆顶元素取出，将其余的数据再进行一遍堆构造
            // 调整a[0...i-1]，使得a[0...i-1]仍然是一个最大堆。
            // 即，保证a[i-1]是a[0...i-1]中的最大值。
            maxHeapDown(a, 0, i - 1);
        }
    }

    /*
     * (最小)堆的向下调整算法
     *
     * 注: 数组实现的堆中，第N个节点的左孩子的索引值是(2N+1)，右孩子的索引是(2N+2)。
     *     其中，N为数组下标索引值，如数组中第1个数对应的N为0。
     *
     * 参数说明:
     *     a -- 待排序的数组
     *     start -- 被下调节点的起始位置(一般为0，表示从第1个开始)
     *     end   -- 截至范围(一般为数组中最后一个元素的索引)
     */
    public static void minHeapDown(int[] a, int start, int end) {
        int c = start;            // 当前(current)节点的位置
        int l = 2 * c + 1;        // 左(left)孩子的位置
        int tmp = a[c];            // 当前(current)节点的大小

        for (; l <= end; c = l, l = 2 * l + 1) {
            // "l"是左孩子，"l+1"是右孩子
            if (l < end && a[l] > a[l + 1])
                l++;        // 左右两孩子中选择较小者
            if (tmp <= a[l])
                break;        // 调整结束
            else {            // 交换值
                a[c] = a[l];
                a[l] = tmp;
            }
        }
    }

    /*
     * 堆排序(从大到小)
     *
     * 参数说明:
     *     a -- 待排序的数组
     *     n -- 数组的长度
     */
    public static void heapSortDesc(int[] a, int n) {
        int i, tmp;

        // 从(n/2-1) --> 0逐次遍历每。遍历之后，得到的数组实际上是一个最小堆。
        for (i = n / 2 - 1; i >= 0; i--)
            minHeapDown(a, i, n - 1);

        // 从最后一个元素开始对序列进行调整，不断的缩小调整的范围直到第一个元素
        for (i = n - 1; i > 0; i--) {
            // 交换a[0]和a[i]。交换后，a[i]是a[0...i]中最小的。
            tmp = a[0];
            a[0] = a[i];
            a[i] = tmp;
            // 调整a[0...i-1]，使得a[0...i-1]仍然是一个最小堆。
            // 即，保证a[i-1]是a[0...i-1]中的最小值。
            minHeapDown(a, 0, i - 1);
        }
    }
}
