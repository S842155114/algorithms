package com.fickle.code.sort;

/**
 * 快速排序(Quick Sort)使用分治法算法思想
 *
 * 快速排序的基本思想是: 选择一个基准数，通过一趟排序将要排序的数据分割成独立的两部分；其中一部分的所有数据都比另外一部分的所有数据都要小。
 * 然后，再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。
 *
 * 从数列中挑出一个基准值。
 * 将所有比基准值小的摆放在基准前面，所有比基准值大的摆在基准的后面(相同的数可以到任一边)；在这个分区退出之后，该基准就处于数列的中间位置。
 * 递归地把"基准值前面的子数列"和"基准值后面的子数列"进行排序。
 * 第一次先覆盖基准值，因为基准值已经用其它变量表示，后续依次覆盖上一步找到的值，最终将基准值覆盖最后一步找到的值
 *
 * 快速排序是不稳定的算法，它不满足稳定算法的定义。
 * 算法稳定性 -- 假设在数列中存在a[i]=a[j]，若在排序之前，a[i]在a[j]前面；并且排序之后，a[i]仍然在a[j]前面。则这个排序算法是稳定的！
 *
 * 快速排序的时间复杂度在最坏情况下是O(N2)，平均的时间复杂度是O(N*lgN)。
 *
 * @author Administrator
 * @apiNote com.fickle.code.sort
 */
public class Quick {
    /*
     * 快速排序
     *
     * 参数说明:
     *     a -- 待排序的数组   {30,40,60,10,20,50}
     *     l -- 数组的左边界(例如，从起始位置开始排序，则l=0)
     *     r -- 数组的右边界(例如，排序截至到数组末尾，则r=a.length-1)
     */
    public static void quickSort(int[] a, int l, int r) {
        // 边界
        if (a == null || a.length < 2 || l >= r) {
            return;
        }
        int i = l, j = r, x = a[i];
        while (i < j) {
            while (i < j && a[j] >= x) { // 从右向左获取小于基准数的数字
                j--;
            }
            if (i < j) {
                a[i++] = a[j]; // 赋值给左侧
            }

            while (i < j && a[i] <= x) { // 从左向右获取小于基准数的数字
                i++;
            }
            if (i < j) {
                a[j--] = a[i]; // 赋值给右侧
            }
        }
        a[i] = x; // 由于上述已经将基准数覆盖，此处写回基准数
        quickSort(a, l, i - 1); // 递归基准数左侧数组
        quickSort(a, i + 1, r); // 递归基准数右侧数组
    }
}
