/**
 * 0-1 背包问题
 * <p>
 * 有一个容量为 N 的背包，要用这个背包装下物品的价值最大，这些物品有两个属性: 体积 w 和价值 v。
 * 定义一个二维数组 dp 存储最大价值，其中 dp[i][j] 表示前 i 件物品体积不超过 j 的情况下能达到的最大价值。
 * <p>
 * 设第 i 件物品体积为 w，价值为 v，根据第 i 件物品是否添加到背包中，可以分两种情况讨论:
 * 第 i 件物品没添加到背包，总体积不超过 j 的前 i 件物品的最大价值就是总体积不超过 j 的前 i-1 件物品的最大价值，dp[i][j] = dp[i-1][j]。
 * 第 i 件物品添加到背包中，在这种前提下，默认j是装满的最大体积，所以如果i要入包，需要i-1预留j的体积，dp[i][j] = dp[i-1][j-w] + v。
 * 第 i 件物品可添加也可以不添加，取决于哪种情况下最大价值更大。
 * <p>
 * 因此，0-1 背包的状态转移方程为:
 * dp[i][j]=max(dp[i-1][j],dp[i-1][j-w] + v)
 * <p>
 * 无法使用贪心算法的解释
 * 0-1 背包问题无法使用贪心算法来求解，也就是说不能按照先添加 性价比最高 的物品来达到最优，这是因为这种方式可能造成背包空间的浪费，从而无法达到最优。
 * 考虑下面的物品和一个容量为 5 的背包，如果先添加物品 0 再添加物品 1，那么只能存放的价值为 16，浪费了大小为 2 的空间。
 * 最优的方式是存放物品 1 和物品 2，价值为 22.
 * id	w	v	v/w
 * 0	1	6	6
 * 1	2	10	5
 * 2	3	12	4
 * <p>
 * 变种
 * 完全背包: 物品数量为无限个
 * 多重背包: 物品数量有限制
 * 多维费用背包: 物品不仅有重量，还有体积，同时考虑这两种限制
 * 其它: 物品之间相互约束或者依赖
 * <p>
 * 01背包：416. 分割等和子集 474. 一和零 494. 目标和 879. 盈利计划 1049. 最后一块石头的重量 II 1230. 抛掷硬币
 * <p>
 * 完全背包：1449. 数位成本和为目标值的最大数字 322. 零钱兑换 518. 零钱兑换 II 279. 完全平方数
 *
 * @author Administrator
 * @apiNote com.fickle.code.thought.dynamic.backpack
 */
package com.fickle.code.thought.dynamic.backpack;